import matplotlib.pyplot as plt
import numpy as np
import os
import re
import scipy.optimize as opt
from scipy.stats import norm

# -------------------------------- general utils -------------------------------

def uncertainty(data, confidence):
    uncertainty = np.std(data, axis=0) / np.sqrt(len(data))
    uncertainty *= (norm.ppf(0.5 + confidence / 2) - norm.ppf(0.5 - confidence / 2)) / 2
    return uncertainty

def fit_and_plot(
        data,
        f,
        plot, # should we plot the data, or just fit and return the parameters?
        show, # True: show the plot, False: save it to a file
        title,
        curve_name,
        xlabel, ylabel,
        p0=None,
        ignore_x_vals=lambda _: False, # x values to ignore when fitting
        notes=[],
    ):
    x = np.linspace(0, data.shape[1], data.shape[1])
    mean = np.mean(data, axis=0)
    sigma = uncertainty(data, 0.68)

    cf_x, cf_mean, cf_sigma = [], [], []
    for xi, meani, sigmai in zip(x, mean, sigma):
        if not ignore_x_vals(xi):
            cf_x.append(xi)
            cf_mean.append(meani)
            cf_sigma.append(sigmai)
    cf_x, cf_mean, cf_sigma = np.array(cf_x), np.array(cf_mean), np.array(cf_sigma)


    popt, _ = opt.curve_fit(f, cf_x, cf_mean, sigma = cf_sigma, maxfev=10000, p0=p0)

    fit_y = f(cf_x, *popt)
    chi_squared = np.sum(((cf_mean - fit_y) ** 2) / (cf_sigma ** 2))
    rsquared = 1 - sum((cf_mean - fit_y) ** 2) / sum((cf_mean - np.mean(cf_mean)) ** 2)

    if plot:
        fit_y = f(x, *popt)
        fig, axs = plt.subplots(2, 1, sharex=True, gridspec_kw={'height_ratios': [3, 2]})

        # draw black dotted line at 0
        axs[1].axhline(0, color='black', linestyle='--', linewidth=1)
        axs[1].axhline(1, color='black', linestyle='dotted', linewidth=1)
        axs[1].axhline(-1, color='black', linestyle='dotted', linewidth=1)

        confidences = [0.68, 0.95]
        colours = ['#2d494f', '#5f7c82']
        axs[0].plot(x, mean, color=colours[0])
        for i in range(len(confidences) - 1, -1, -1):
            confidence = confidences[i]
            bar_height = uncertainty(data, confidences[i])

            axs[0].fill_between(x, mean - bar_height, mean + bar_height, color=colours[i], alpha=0.5, label=f"{confidence:.0%} confidence", edgecolor='none')

        params = {'label': curve_name + " fit", 'color': '#f2a900', 'linewidth': 1.5}
        axs[0].plot(x, fit_y, **params)
        axs[1].plot(x, (fit_y - mean) / sigma, marker='o', markersize=3, **params)

        axs[1].set_xlabel(xlabel, fontsize=12)
        axs[0].set_ylabel(ylabel, fontsize=12)
        axs[1].set_ylabel("Curve Residuals (σ)", fontsize=12)

        axs[0].legend()
        axs[0].set_title(title, fontsize=12)

        text = []
        text.append(("", 12))
        text.append((f"For {curve_name} fit:", 12))
        text.append((f"    χ² = {chi_squared:.2f}", 12))
        text.append((f"    R² = {rsquared:.4f}", 12))
        text.append(("", 12))
        for note in notes:
            text.append((note, 10))

        # write some text at the bottom
        total_adj = 0.05
        for line, size in reversed(text):
            fig.text(0.1, total_adj, line, fontsize=size)
            total_adj += 0.02 * size / 8
        total_adj += 0.05
        fig.subplots_adjust(bottom=total_adj)

        # set the aspect ratio
        fig.set_figwidth(10)
        fig.set_figheight(7)


        # tune out y ticks on the residuals plot
        y_ticks = [-5, -3, -1, 0, 1, 3, 5]
        axs[1].set_ylim(-y_ticks[-1], y_ticks[-1])
        axs[1].set_yticks(y_ticks)
        axs[1].set_yticklabels(map(lambda x: f"{int(x)}σ", y_ticks))

        if show:
            plt.show()
        else:
            filename = re.sub(r'\s+', '_', title)
            filename = re.sub(r'\W+', '', filename)
            iter = 0
            while os.path.exists(f'{filename}_{iter}.png'): iter += 1
            plt.savefig(f'{filename}_{iter}.png')

        plt.close()

    return popt, chi_squared, rsquared





# ---------------------- analysis part 1: malus' law ---------------------------
#
# each data in this series is generated by
# 1. shining a laser through
# 2. a polarising filter mounted stepper motor
# 3. into a photodiode
# 4. and recording the intensity of the light as the motor rotates the filter


data = []
for filename in os.listdir('data'):
    if filename.startswith('polarised_10000_'):
        data.append(np.loadtxt('data/' + filename))

data = np.array(data)

# we should have exactly 400 data points per run, corresponding to 1 full rotation
assert data.shape[1] == 400

def f(x, a, b, theta):
    return a * np.cos(2 * np.pi * x / 400 + theta) ** 2 + b

(a, b, theta), chi_squared, rsquared = fit_and_plot(data, f, True, False,
    f'Intensity vs Angle of Polarising Filter\n{len(data)} repetitions',
    '$\\cos^2$',
    'Stepper Motor Position [1/400ths of a cycle]',
    'Photodiode Intensity [ADC reading]')

# mod pi instead of 2pi, since that's the period of cos^2
print(f'Fit parameters: a = {a}, b = {b}, theta = {theta % np.pi}')

angle = (-theta) % np.pi
angle = 400 * angle / (2 * np.pi)
print(f'Max is at {angle} and {angle + 200} steps')

# ---------------------- analysis part 2: brewster's angle ---------------------

data = []
for filename in os.listdir('data'):
    if filename.startswith('transparent_10000_'):
        data.append(np.loadtxt('data/' + filename)[::-1])
data = np.array(data)

# we should have exactly 100 data points per run, corresponding to 90 degrees
assert data.shape[1] == 100

def transmittance(theta_i, n_1, n_2):
    theta_t = np.arcsin(np.sin(theta_i) * n_1 / n_2)
    r_s = ((n_1 * np.cos(theta_i) - n_2 * np.cos(theta_t)) / (n_1 * np.cos(theta_i) + n_2 * np.cos(theta_t))) ** 2
    r_p = ((n_1 * np.cos(theta_t) - n_2 * np.cos(theta_i)) / (n_1 * np.cos(theta_t) + n_2 * np.cos(theta_i))) ** 2
    r = (r_s + r_p) / 2
    t = 1 - r
    return t, theta_t

# from the Fresnel equations:
def f(x, a, b, n_1, n_2):
    theta_i = x * 2 * np.pi / 400
    t1, theta_t1 = transmittance(theta_i, n_1, n_2) # transmittance from the air into the glass
    t2, _        = transmittance(theta_t1, n_2, n_1) # transmittance from the glass back into the air
    return a * t1 * t2  + b # ignores possibility for multiple internal reflections


(a, b, n_1, n_2), chi_squared, rsquared = fit_and_plot(data, f, True, True,
    f'Transmittance as a function of Incident Angle\n{len(data)} repetitions',
    'Fresnel Equation Transmittance Curve',
    'Stepper Motor Position [1/400ths of a cycle]',
    'Photodiode Intensity [ADC reading]',
    p0=[300, 100, 1, 1.5],
    ignore_x_vals=lambda x: x > 92,
    notes=[
        "Angle is measured in 1/400ths of a cycle",
        "0 corresponds to the laser oriented normal to the glass slide",
        "100 corresponds to the laser oriented parallel to the glass slide",
        "",
        "X values greater than 96 were ignored from fit calculations, as they",
        " allowed an internal reflection to pass out of the side of the glass",
        " slide and into the photodiode."
    ])




