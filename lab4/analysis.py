import matplotlib.pyplot as plt
import numpy as np
import os
import scipy.optimize as opt
from scipy.stats import norm

# -------------------------------- general utils -------------------------------

def uncertainty(data, confidence):
    uncertainty = np.std(data, axis=0) / np.sqrt(len(data))
    uncertainty *= (norm.ppf(0.5 + confidence / 2) - norm.ppf(0.5 - confidence / 2)) / 2
    return uncertainty

def fit_and_plot(data, f, plot, title, curve_name, xlabel, ylabel):
    x = np.linspace(0, data.shape[1], data.shape[1])
    mean = np.mean(data, axis=0)
    sigma = uncertainty(data, 0.68)
    popt, _ = opt.curve_fit(f, x, mean, sigma = sigma)
    fit_y = f(x, *popt)
    chi_squared = (1 / len(x)) * np.sum(((mean - fit_y) ** 2) / (sigma ** 2))
    rsquared = 1 - sum((mean - fit_y) ** 2) / sum((mean - np.mean(mean)) ** 2)

    if plot:
        fig, axs = plt.subplots(2, 1, sharex=True, gridspec_kw={'height_ratios': [3, 2]})

        # draw black dotted line at 0
        axs[1].axhline(0, color='black', linestyle='--', linewidth=1)
        axs[1].axhline(1, color='black', linestyle='dotted', linewidth=1)
        axs[1].axhline(-1, color='black', linestyle='dotted', linewidth=1)

        confidences = [0.68, 0.95]
        colours = ['#2d494f', '#5f7c82']
        for i in range(len(confidences) - 1, -1, -1):
            confidence = confidences[i]
            bar_height = uncertainty(data, confidences[i])

            axs[0].fill_between(x, mean - bar_height, mean + bar_height, color=colours[i], alpha=0.5, label=f"{confidence:.0%} confidence")

        params = {'label': curve_name + " fit", 'color': '#f2a900', 'linewidth': 1.5}
        axs[0].plot(x, fit_y, **params)
        axs[1].plot(x, (fit_y - mean) / sigma, marker='o', markersize=3, **params)

        axs[1].set_xlabel(xlabel, fontsize=12)
        axs[0].set_ylabel(ylabel, fontsize=12)
        axs[1].set_ylabel("Curve Residuals (σ)", fontsize=12)

        axs[0].legend()
        axs[0].set_title(title, fontsize=12)

        text = []
        text.append((f"For {curve_name} fit:", 12))
        text.append((f"    χ² = {chi_squared:.2f}", 12))
        text.append((f"    R² = {rsquared:.4f}", 12))

        # write some text at the bottom
        total_adj = 0.05
        for line, size in reversed(text):
            fig.text(0.1, total_adj, line, fontsize=size)
            total_adj += 0.02 * size / 8
        total_adj += 0.05
        print(total_adj)
        fig.subplots_adjust(bottom=total_adj)

        # set the aspect ratio
        fig.set_figwidth(10)
        fig.set_figheight(7)


        # tune out y ticks on the residuals plot
        y_ticks = [-5, -3, -1, 0, 1, 3, 5]
        print(y_ticks)
        axs[1].set_ylim(-y_ticks[-1], y_ticks[-1])
        axs[1].set_yticks(y_ticks)
        axs[1].set_yticklabels(map(lambda x: f"{int(x)}σ", y_ticks))

        plt.show()

# ---------------------- analysis part 1: polarised light ----------------------
# each data in this series is generated by
# 1. shining a laser through
# 2. a polarising filter mounted stepper motor
# 3. into a photodiode
# 4. and recording the intensity of the light as the motor rotates the filter


data = []
for filename in os.listdir('data'):
    if filename.startswith('polarised_10000_'):
        data.append(np.loadtxt('data/' + filename))

data = np.array(data)

# we should have exactly 400 data points per run, corresponding to 1 full rotation
assert data.shape[1] == 400

def f(x, a, b, theta):
    return a * np.cos(2 * np.pi * x / 400 + theta) ** 2 + b

fit_and_plot(data, f, True,
    f'Intensity vs Angle of Polarising Filter\n{len(data)} repetitions',
    '$\\cos^2$',
    'Stepper Motor Position [1/400ths of a cycle]',
    'Photodiode Intensity [ADC reading]')
